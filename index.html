<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>integrationtest</title>
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Raleway:wght@300;400;500;700&display=swap"
      rel="stylesheet"
    />
    <style>
      body {
        margin: 0;
        overflow: hidden;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        background-color: #f0f0f0; /* light background */
        font-family: "Roboto", sans-serif;
        color: #333; /* Dark text color for contrast */
      }
      canvas {
        object-fit: cover;
      }
      .flip-button {
        width: 40px;
        height: 40px;
        border-radius: 50%;
        background-color: rgba(0, 0, 0, 0.1); /* light background for button*/
        border: none;
        cursor: pointer;
        position: absolute;
        bottom: 55px;
        right: 40px;
        margin-right: -20px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: transform 0.2s ease;
      }

      .flip-button:hover {
        transform: scale(1.1);
      }

      .flip-button::before {
        content: "";
        background-image: url("/flip.png"); /*  Make sure this path is correct! */
        width: 24px;
        height: 24px;
        background-size: contain;
        background-repeat: no-repeat;
        background-position: center;
        transform: rotate(var(--current-rotation, 0deg));
        transition: transform 0.3s ease;
        filter: none;
      }

      .flip-button.animate-flip::before {
        /* no additional transform here, rotation handled by transition*/
      }
      .record-button {
        width: 70px;
        height: 70px;
        border-radius: 50%;
        background-color: #ddd; /* Light background for record button */
        border: none;
        cursor: pointer;
        position: absolute;
        transition: transform 0.2s ease;
        bottom: 40px;
        left: 50%;
        transform: translate(-50%, 0%);
        display: flex;
        align-items: center;
        justify-content: center;
        overflow: visible;
      }

      .record-button:hover {
        transform: scale(1.1) translate(-50%, 0%);
      }

      .record-button::before {
        content: "";
        position: absolute;
        width: 60px;
        height: 60px;
        border-radius: 50%;
        border: 4px solid rgba(0, 0, 0, 0.1);
        box-sizing: border-box;
      }

      .progress-ring {
        display: none;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        width: 70px;
        height: 70px;
        pointer-events: none;
      }

      .progress-ring svg {
        display: block;
      }

      .progress-ring circle {
        fill: none;
        stroke: rgba(0, 0, 0, 0.2); /* Use dark color for circle */
        stroke-width: 4;
        r: 30;
        cx: 35;
        cy: 35;
        transform-origin: center;
      }

      .progress-ring path {
        fill: none;
        stroke: #ff4d4d; /* Use red for progress color */
        stroke-width: 4;
        stroke-dasharray: 188;
        stroke-dashoffset: 188;
        transform: rotate(-0deg);
        transform-origin: center;
        transition: stroke-dashoffset 0.25s linear;
      }

      .red-dot {
        position: absolute;
        width: 20px;
        height: 20px;
        border-radius: 50%;
        background-color: #ff4d4d; /* Red color for recording dot */
        opacity: 0;
        transition: opacity 0.2s ease;
      }

      .record-button.recording .red-dot {
        opacity: 1;
        animation: pulse 1.2s infinite;
      }

      @keyframes pulse {
        0% {
          transform: scale(1);
        }
        50% {
          transform: scale(1.2);
        }
        100% {
          transform: scale(1);
        }
      }

      .preview-modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.5);
        backdrop-filter: blur(10px);
        justify-content: center;
        align-items: center;
        z-index: 1000;
        flex-direction: column;
        opacity: 0;
        transition: opacity 0.3s ease;
      }

      .preview-modal.show {
        opacity: 1;
      }

      .preview-modal video {
        max-width: 90%;
        max-height: 70%;
        border-radius: 10px;
        box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        transition: transform 0.3s ease;
        transform: translateY(-20px);
      }

      .preview-modal.show video {
        transform: translateY(0);
      }

      .preview-modal .buttons-container {
        display: flex;
        margin-top: 30px;
        gap: 15px;
      }

      .preview-modal button {
        background-color: rgba(255, 255, 255, 0.8); /* light background */
        padding: 10px 20px;
        border-radius: 25px;
        cursor: pointer;
        border: none;
        color: #333; /* Dark text color for buttons */
        font-size: 16px;
        transition: background-color 0.2s ease;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        font-family: "Raleway", sans-serif;
      }

      .preview-modal button:hover {
        background-color: rgba(255, 255, 255, 0.9);
      }

      .close-modal-button {
        position: absolute;
        top: 15px; /* Adjusted top spacing */
        right: 15px; /* Adjusted right spacing */
        background-color: rgba(255, 255, 255, 0.4); /* Semi transparent light background */
        border: none;
        color: #333;
        font-size: 25px;
        border-radius: 100%;
        width: 30px;
        height: 30px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        line-height: 1; /* Vertically center the X */
      }

      /* Styles for dynamically added elements */
      #convert-button,
      #loading-indicator, #save-mp4-button {
        margin: 10px;
        padding: 8px 16px;
        border: 1px solid #ccc;
        border-radius: 4px;
        background-color: #f0f0f0;
        cursor: pointer;
      }
      #loading-indicator {
        color: red;
        border: none;
      }

      #convert-button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }
    </style>
  </head>
  <body>
    <canvas id="canvas"></canvas>
    <button
      class="record-button"
      id="record-button"
      aria-label="Start Recording"
    >
      <div class="red-dot"></div>
      <div class="progress-ring" id="progress-ring">
        <svg width="100%" height="100%" viewBox="0 0 70 70">
          <circle cx="35" cy="35" r="30" />
          <path
            id="progress-path"
            d="M35,5 A30,30 0 1,1 35,65 A30,30 0 1,1 35,5"
          />
        </svg>
      </div>
    </button>
    <button class="flip-button" id="flip-button" aria-label="Flip Camera"></button>
    <div class="preview-modal" id="preview-modal">
      <button class="close-modal-button" id="close-modal-button">Ã—</button>
      <video id="preview-video" controls></video>
      <div class="buttons-container">
        <button id="share-button">Share</button>
        <button id="save-button">Save WebM</button>
      </div>
    </div>

    <!-- Include ffmpeg.wasm -->
    <script src="https://unpkg.com/@ffmpeg/ffmpeg@0.11.6/dist/ffmpeg.min.js"></script>
    <script src="https://unpkg.com/@ffmpeg/core@0.11.0/dist/ffmpeg-core.js"></script>

    <script type="module">
      import {
        bootstrapCameraKit,
        CameraKitSession,
        createMediaStreamSource,
        Transform2D,
      } from "https://cdn.jsdelivr.net/npm/@snap/camera-kit@0.23.0/dist/esm/index.mjs"; //Use a CDN version of Camera Kit.

      const liveRenderTarget = document.getElementById("canvas");
      const flipButton = document.getElementById("flip-button");
      const recordButton = document.getElementById("record-button");
      const progressRing = document.getElementById("progress-ring");
      const progressPath = document.getElementById("progress-path");
      const previewModal = document.getElementById("preview-modal");
      const previewVideo = document.getElementById("preview-video");
      const shareButton = document.getElementById("share-button");
      const saveButton = document.getElementById("save-button");
      const closeModalButton = document.getElementById("close-modal-button");
      const buttonsContainer = document.querySelector(".buttons-container");

      let isBackFacing = true;
      let mediaStream;
      let isFlipping = false;
      let currentRotation = 0; // Track the current rotation
      let session;
      let mediaRecorder = null;
      let downloadUrl = null;
      let recordingStartTime = null;
      const RECORD_DURATION = 60;

      async function init() {
        const cameraKit = await bootstrapCameraKit({
          apiToken:
            "eyJhbGciOiJIUzI1NiIsImtpZCI6IkNhbnZhc1MyU0hNQUNQcm9kIiwidHlwIjoiSldUIn0.eyJhdWQiOiJjYW52YXMtY2FudmFzYXBpIiwiaXNzIjoiY2FudmFzLXMyc3Rva2VuIiwibmJmIjoxNzI2NTY1MzEwLCJzdWIiOiIyN2NmNDQwYy04YjBkLTQ5ZDEtYTM2MC04YjdkODQ5OTM3ZWJ-U1RBR0lOR340Y2ZhYTJiOC1kYWY4LTRhZDYtODYwNy1iMmI5NWYzMDVmMzAifQ.q8qMDDOzMv4jFiZ8NRqQ8-qDJMV4l5YmOex67WC6DqI",
        });
        const devicePixelRatio = window.devicePixelRatio || 1;
        const desiredAspectRatio = 9 / 16; // Example 9:16 ratio (e.g., portrait)

        // Calculate the best fit canvas dimensions based on screen and aspect ratio
        let canvasWidth;
        let canvasHeight;

        if (window.innerWidth / window.innerHeight > desiredAspectRatio) {
          // If the screen is wider than the desired aspect ratio, set height to match screen
          canvasWidth = window.innerWidth;
          canvasHeight = window.innerWidth / desiredAspectRatio;
        } else {
          //If the screen is taller than the desired aspect ratio, set width to match screen
          canvasHeight = window.innerHeight;
          canvasWidth = window.innerHeight * desiredAspectRatio;
        }

        liveRenderTarget.width = canvasWidth * devicePixelRatio;
        liveRenderTarget.height = canvasHeight * devicePixelRatio;
        liveRenderTarget.style.width = `${canvasWidth}px`;
        liveRenderTarget.style.height = `${canvasHeight}px`;
        liveRenderTarget.style.position = "fixed";
        liveRenderTarget.style.left = "50%";
        liveRenderTarget.style.top = "50%";
        liveRenderTarget.style.transform = "translate(-50%, -50%)";

        session = await cameraKit.createSession({ liveRenderTarget });

        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: isBackFacing ? "environment" : "user",
            width: { ideal: 1920 },
            height: { ideal: 1080 },
          },
        });

        const source = createMediaStreamSource(mediaStream);

        await session.setSource(source);
        if (!isBackFacing) {
          source.setTransform(Transform2D.MirrorX);
        }

        await session.play();

        const lens = await cameraKit.lensRepository.loadLens(
          "77b918f0-930f-423c-be8b-05c1ccd96747",
          "11cbcba2-1275-47ec-9916-feaa6c52d24b"
        );
        await session.applyLens(lens);
        bindFlipCamera(session);
        bindRecorder();
        bindModal();
      }

      function bindFlipCamera(session) {
        flipButton.style.cursor = "pointer";

        flipButton.addEventListener("click", () => {
          if (!isFlipping) {
            flipButton.classList.add("animate-flip");
            updateCamera(session);
          }
        });

        updateCamera(session);
      }

      async function updateCamera(session) {
        isFlipping = true;
        flipButton.disabled = true;
        isBackFacing = !isBackFacing;

        if (mediaStream) {
          session.pause();
          mediaStream.getVideoTracks()[0].stop();
        }

        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: isBackFacing ? "environment" : "user",
            width: { ideal: 1920 },
            height: { ideal: 1080 },
          },
        });

        const source = createMediaStreamSource(mediaStream);

        await session.setSource(source);

        if (!isBackFacing) {
          source.setTransform(Transform2D.MirrorX);
        }

        session.play();

        currentRotation += 180; // Update current rotation
        flipButton.style.setProperty("--current-rotation", `${currentRotation}deg`);
        setTimeout(() => {
          isFlipping = false;
          flipButton.disabled = false;
          flipButton.classList.remove("animate-flip");
        }, 500);
      }

      function bindRecorder() {
        recordButton.addEventListener("click", () => {
          if (mediaRecorder?.state === "recording") {
            stopRecording();
          } else {
            startRecording();
          }
        });
      }

      async function startRecording() {
        recordButton.classList.add("recording");
        progressRing.style.display = "block";

        const mediaStream = liveRenderTarget.captureStream(30);

        mediaRecorder = new MediaRecorder(mediaStream);

        const chunks = [];

        mediaRecorder.addEventListener("dataavailable", (event) => {
          if (event.data.size > 0) {
            chunks.push(event.data);
          }
        });

        mediaRecorder.addEventListener("stop", () => {
          const blob = new Blob(chunks, { type: "video/webm" }); // Specify MIME type
          downloadUrl = window.URL.createObjectURL(blob);
          previewVideo.src = downloadUrl;
          previewModal.style.display = "flex";
          previewModal.classList.add("show");
          recordButton.classList.remove("recording");
          progressRing.style.display = "none";
        });

        mediaRecorder.start();
        recordingStartTime = Date.now();
        updateProgress();
      }

      function updateProgress() {
        if (
          !mediaRecorder ||
          mediaRecorder.state !== "recording" ||
          !recordingStartTime
        ) {
          return;
        }

        const elapsedTime = Date.now() - recordingStartTime;
        const progressPercentage = Math.min(
          100,
          (elapsedTime / 1000 / RECORD_DURATION) * 100
        );
        const circumference = 2 * Math.PI * 30;
        const dashOffset = circumference * (1 - progressPercentage / 100);

        if (progressPath instanceof SVGPathElement) {
          progressPath.style.strokeDashoffset = String(dashOffset);
        }

        if (elapsedTime / 1000 >= RECORD_DURATION) {
          stopRecording();
        } else {
          requestAnimationFrame(updateProgress);
        }
      }

      function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === "recording") {
          mediaRecorder.stop();
        }
        recordingStartTime = null;
        if (progressPath instanceof SVGPathElement) {
          progressPath.style.strokeDashoffset = String(188);
        }

        recordButton.classList.remove("recording");
        progressRing.style.display = "none";
      }

      function bindModal() {
          const convertButton = document.createElement("button");
          convertButton.textContent = "Convert to MP4";
          convertButton.id = "convert-button";
          convertButton.disabled = true;

          const loadingIndicator = document.createElement("div");
          loadingIndicator.textContent = "Converting...";
          loadingIndicator.id = "loading-indicator";
          loadingIndicator.style.display = "none";

          buttonsContainer.appendChild(convertButton);
          buttonsContainer.appendChild(loadingIndicator);

        closeModalButton.addEventListener("click", () => {
          previewModal.style.display = "none";
          previewModal.classList.remove("show");
          previewVideo.pause();
          previewVideo.currentTime = 0;
            // Clean up dynamically added buttons. VERY IMPORTANT.
            const saveMp4Button = document.getElementById("save-mp4-button");
            if (saveMp4Button) {
                buttonsContainer.removeChild(saveMp4Button);
            }
            if (document.getElementById("convert-button")) {
               buttonsContainer.removeChild(convertButton);
           }
           if (document.getElementById("loading-indicator")) {
               buttonsContainer.removeChild(loadingIndicator);
           }
        });

        shareButton.addEventListener("click", async () => {
          if (downloadUrl) {
            const blob = await fetch(downloadUrl).then((r) => r.blob());
            const filesArray = [
              new File([blob], "video.webm", { type: "video/webm" }),
            ];
            if (navigator.canShare && navigator.canShare({ files: filesArray })) {
              navigator.share({
                files: filesArray,
              });
            }
          }
        });

          saveButton.addEventListener("click", () => {
            if (downloadUrl) {
              const link = document.createElement("a");
              link.style.display = "none";
              link.href = downloadUrl;
              link.download = "camera-kit-web-recording.webm";
              document.body.appendChild(link); // Append for Firefox
              link.click();
              document.body.removeChild(link); // Clean up
            }
          });


          // Enable convert button and handle conversion.
        let mp4DownloadUrl = null;

        convertButton.addEventListener("click", async () => {
          if (!downloadUrl) return;

          convertButton.disabled = true;
          loadingIndicator.style.display = "block";

          try {
            const ffmpeg = new FFmpeg();
              if (!ffmpeg.isLoaded()) {
                  await ffmpeg.load();
              }

            const webmBlob = await fetch(downloadUrl).then((r) => r.blob());
            const webmBuffer = await webmBlob.arrayBuffer();

            ffmpeg.writeFile("input.webm", new Uint8Array(webmBuffer));

            await ffmpeg.exec([
              "-i",
              "input.webm",
              "-c:v",
              "libx264",
              "-preset",
              "fast",
              "-crf",
              "23",
              "-c:a",
              "aac",
              "-b:a",
              "128k",
              "output.mp4",
            ]);

            const mp4Data = ffmpeg.readFile("output.mp4");
            const mp4Blob = new Blob([mp4Data.buffer], { type: "video/mp4" });
            mp4DownloadUrl = URL.createObjectURL(mp4Blob);

            const saveMp4Button = document.createElement("button");
            saveMp4Button.textContent = "Save MP4";
            saveMp4Button.id = "save-mp4-button"; // Add an ID for removal later
            saveMp4Button.addEventListener("click", () => {
              const link = document.createElement("a");
              link.href = mp4DownloadUrl;
              link.download = "camera-kit-web-recording.mp4";
              link.style.display = "none";
              document.body.appendChild(link);
              link.click();
              document.body.removeChild(link);
            });
              buttonsContainer.appendChild(saveMp4Button);
              loadingIndicator.style.display = "none";

          } catch (error) {
            console.error("Error converting video:", error);
            loadingIndicator.textContent = "Conversion Failed";
            convertButton.disabled = false; // Re-enable for retries
          }
        });
            // Observe the video element's src attribute
            const observer = new MutationObserver(mutations => {
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'src' && previewVideo.src) {
                        convertButton.disabled = false;
                        observer.disconnect(); // Stop observing after the first change
                    }
                });
            });
             // Start observing the video element
            observer.observe(previewVideo, { attributes: true });
      }

      init();
    </script>
  </body>
</html>